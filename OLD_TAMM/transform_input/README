
Prereq: pip install antlr4-python2-runtime

To run (cd to transform_input folder)
--------------------------------------

*** Input filename should be of the form method_ti.extensions ex: ccsd_t1.eq.in.nwc ***

- Following takes equation in icsd_t2 fortran code comments and generates levelized input with stmt labels
   python nwchem_to_levelized.py icsd_t2.eq.nwc > icsd_t2.eq.lvl 

- Following takes the above levelized code and generates icsd_t2 reference C code
   python generate_ref_c_code.py icsd_t2.eq.lvl > icsd_t2_ref.cc

- icsd_t2.eq.lvl  is also provided as input to tamm_parser

-------------------------------------------

So's Input -> Pai-Wei's opmin input (python SoInput_to_Opmin/So_to_opmin.py SoInput_to_Opmin/SoEqns/ccsd_t1.eq > ccsd_t1.op.in)
 - Remove Sum and symmetry/permutation information
 - Assume array is indexed only with hi and pi with ranges O and V.
 - rename any tensor x to x_type ex: t_oovv
 - array refs such as t1(h2 h3* hc hv) h3* is deleted and array is declared accordingly
   - To test this case use: 
          python SoInput_to_Opmin/So_to_opmin.py SoInput_to_Opmin/SoEqns/ipeomccsdtq_x2.eq > ipeomccsdtq_x2.op.in
          python src/opmin.py ipeomccsdtq_x2.op.in
          python opmin_to_tamm.py ipeomccsdtq_x2.op.in.out > ipeomccsdtq_x2.op.in.tamm


Run Pai-Wei's Opmin -> python src/opmin.py ccsd_t1.op.in  -> generates ccsd_t1.op.in.out

Pai-Wei's output -> tamm_input  (python opmin_to_tamm.py ccsd_t1.op.in.out > ccsd_t1.op.tamm )
 - Remove braces around array decls
 - Collapse the f_... and v_... array delcarations (with range N) and their usage to f and v 


python opmin_to_tamm.py ccsd_t1.op.in.out (generates ccsd_t1.op.in.out_generated_splitAdds.eq)
python tamm_to_tamm.py ccsd_t1.op.in.out_generated_splitAdds.eq 999 > $eqname_final.eq (only minimize intermediates)

-----------------------------------
   RUNNING THE UNFACTORIZER
-----------------------------------

In transform_input folder:

# For each term (defined as a product of tensors), find out the case where we have symmetric loops. We have a symmetric loop
# for a subset of summation indices if they are of the same type (O or V) and appear together in exactly two tensors.
# Let us say these subsets are of size k1, k2, etc.
# Option 1: For this term, we MULTIPLY it's existing constant by the factor k1! * k2! *
# Option 2: For this term, we DIVIDE it's existing constant by the factor k1! * k2! *

	python tamm_to_tamm.py eqfile mdoption user_O user_V (mdoption=0 for multiply, >0 for divide,
	                        999 to skip mult,div and only minimize intermediates given a tamm input file)
	python unfactorize.py eqname_initial.eq > eqname_initial_un.eq
	python ../opmin/src/opmin.py $eqname_initial_un.eq
	mv eqname_initial_un.eq.out eqname_opmin_generated.eq
	python opmin_to_tamm.py $eqname_opmin_generated.eq
	python tamm_to_tamm.py $eqname_opmin_generated_splitAdds.eq 1 > $eqname_final.eq (divide constants)

