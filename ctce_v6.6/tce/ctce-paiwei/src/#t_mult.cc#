#include "t_mult.h"
using namespace std;

namespace ctce {

  extern "C" {

    void t_mult(Integer* d_a, Integer* k_a_offset,
        Integer* d_b, Integer* k_b_offset, double *a_c,
        Tensor &tC, Tensor &tA, Tensor &tB, const double coef,
        const vector<IndexName>& sum_ids,
        IterGroup <triangular>& sum_itr,
        IterGroup<CopyIter>& cp_itr,
        const vector<Integer>& tid) {

      vector<Integer>& vtab = Table::value();
      const vector<IndexName>& c_ids = tC.name();
      const vector<IndexName>& a_ids = tA.name();
      const vector<IndexName>& b_ids = tB.name();

      for (int i = 0; i < tC.dim(); ++i) {
        vtab[c_ids[i]] = tid[i]; // values used in genAntiIter
      }

      IterGroup<antisymm> ext_itr;
      genAntiIter(ext_itr,tC,tA,tB);
      vector<Integer> ext_vec, sum_vec;
      ext_itr.reset();

      while (ext_itr.next(ext_vec)) {

        if (is_spatial_nonzero(ext_vec, tA.irrep() ^ tB.irrep()) &&
            is_spin_nonzero(ext_vec) &&
            is_spin_restricted_nonzero(ext_vec, 2 * tC.dim())) {

          for (int i = 0; i < tC.dim(); ++i) {
            vtab[c_ids[i]] = ext_vec[i];
            tC.setValueByName(c_ids[i], vtab[c_ids[i]]);
          }
          for (int i = 0; i < tA.dim(); ++i) tA.setValueByName(a_ids[i], vtab[a_ids[i]]);
          for (int i = 1; i < tB.dim(); ++i) tB.setValueByName(b_ids[i], vtab[b_ids[i]]);
          const vector<Integer>& c_ids_v = tC.value();
          Integer dimc = compute_size(c_ids_v);
          if (dimc == 0) continue;
          double* buf_c_sort = new double[dimc];
          memset(buf_c_sort, 0, dimc * sizeof(double));

          sum_itr.reset();
          bool ONE_TIME = sum_itr.empty();
          while (sum_itr.next(sum_vec) || ONE_TIME) {

            ONE_TIME = false;
            for (int i=0; i<sum_ids.size(); i++) {
              tA.setValueByName(sum_ids[i],sum_vec[i]);
              tB.setValueByName(sum_ids[i],sum_vec[i]);
            }
            vector<Integer> a_ids_v = tA.value();
            vector<Integer> b_ids_v = tB.value();
            if(!is_spatial_nonzero(a_ids_v, tA.irrep()))  continue;
            if(!is_spin_nonzero(a_ids_v)) continue;

            tA.gen_restricted();
            tB.gen_restricted();

            Integer dim_common = compute_size(sum_vec);
            Integer dima = compute_size(a_ids_v); if (dima<=0) continue;
            Integer dimb = compute_size(b_ids_v); if (dimb<=0) continue;
            Integer dima_sort = dima / dim_common;
            Integer dimb_sort = dimb / dim_common;

            double* buf_a = new double[dima];
            double* buf_a_sort = new double[dima];
            tA.sortByValueThenExtSymGroup();
            if (tA.dim()==2) tA.get_ma = true;
            tA.get(*d_a,buf_a,dima,*k_a_offset);
            tce_sort(buf_a, buf_a_sort, tA._value(), tA.sort_ids(), (double)tA.sign());
            delete [] buf_a;

            double* buf_b = new double[dimb];
            double* buf_b_sort = new double[dimb];
            tB.sortByValueThenExtSymGroup();
            if (!tB.isIntermediate()) tB.get_i = true;
            tB.get(*d_b,buf_b,dimb,*k_b_offset);
            tce_sort(buf_b, buf_b_sort, tB._value(), tB.sort_ids(), (double)tB.sign());
            delete [] buf_b;

	    ctce_prof_start_timer_inner("dgemm");
            cdgemm('T','N', dima_sort, dimb_sort, dim_common, 1.0, buf_a_sort,
                dim_common, buf_b_sort, dim_common, 1.0, buf_c_sort, dima_sort);
	    ctce_prof_start_timer_inner("dgemm");

            delete [] buf_a_sort;
            delete [] buf_b_sort;
          } // sum_itr

          tC.sortByValueThenExtSymGroup();
          cp_itr.reset();
          vector<Integer> perm;
          while (cp_itr.next(perm)) {
            cp_itr.fix_ids_for_copy(perm);
            tC.orderIds(perm);
            if (compareVec<Integer>(tid,tC._value())) {
              double sign = coef * cp_itr.sign();
              sortacc(buf_c_sort, a_c, tC.getMemPosVal(), tC.perm(), sign);
            }
          } // cp_itr
          delete [] buf_c_sort;
        } // if spatial check

      } // ext_itr

    } // t_mult

    void t_mult2(Integer* d_a, Integer* k_a_offset, Integer* d_b, Integer* k_b_offset,
        Integer* d_c, Integer* k_c_offset,
        Tensor& tC, Tensor& tA, Tensor& tB, const double coef,
        const vector<IndexName>& sum_ids,
        IterGroup<triangular>& sum_itr,
        IterGroup<CopyIter>& cp_itr,
        IterGroup<triangular>& out_itr) {

      vector<Integer> out_vec;
      out_itr.reset();
      double anti=0, add=0;
      while (out_itr.next(out_vec)) {
        if (!is_spatial_nonzero(out_vec, tA.irrep() ^ tB.irrep())) continue;
        if (!is_spin_nonzero(out_vec)) continue;
        if (!is_spin_restricted_nonzero(out_vec, 2 * tC.dim())) continue;
        Integer dimc = compute_size(out_vec);
        if (dimc <= 0) continue;
        double* buf_c = new double[dimc];
        memset(buf_c, 0, dimc * sizeof(double));

        t_mult(d_a,k_a_offset,d_b,k_b_offset,buf_c,
            tC,tA,tB,coef,sum_ids,sum_itr,cp_itr,out_vec);

        tce_add_hash_block_(d_c, buf_c, dimc, *k_c_offset, out_vec, tC.name());
        delete [] buf_c;
      }

    } // t_mult2

    void t_mult3(Integer* d_a, Integer* k_a_offset, Integer* d_b, Integer* k_b_offset,
        Integer* d_c, Integer* k_c_offset,
        Tensor& tC, Tensor& tA, Tensor& tB, const double coef,
        const vector<IndexName>& sum_ids,
        IterGroup<triangular>& sum_itr,
        IterGroup<CopyIter>& cp_itr,
        IterGroup<triangular>& out_itr) {

      vector<Integer>& vtab = Table::value();
      const vector<IndexName>& c_ids = tC.name();
      const vector<IndexName>& a_ids = tA.name();
      const vector<IndexName>& b_ids = tB.name();

      // GA initialization
      int nprocs = GA_Nnodes();
      int count = 0;
      int taskDim = 1;
      char taskStr[10] = "NXTASK";
      int taskHandle = NGA_Create(C_INT,1,&taskDim,taskStr,NULL); // global array for next task
      GA_Zero(taskHandle); // initialize to zero
      GA_Sync();

      int sub = 0;
      int next = NGA_Read_inc(taskHandle, &sub, 1);

      vector<Integer> out_vec, sum_vec;
      out_itr.reset();

      while (out_itr.next(out_vec)) {

        if (next==count) { // check if its my task

          if ( (is_spatial_nonzero(out_vec, tA.irrep() ^ tB.irrep())) &&
              (is_spin_nonzero(out_vec)) &&
              (is_spin_restricted_nonzero(out_vec, 2*tC.dim())) ) {

            for (int i=0; i<tC.dim(); i++) {
              vtab[c_ids[i]]=out_vec[i];
              tC.setValueByName(c_ids[i],out_vec[i]);
            }
            for (int i=0; i<tA.dim(); i++) tA.setValueByName(a_ids[i],vtab[a_ids[i]]);
            for (int i=0; i<tB.dim(); i++) tB.setValueByName(b_ids[i],vtab[b_ids[i]]);
            const vector<Integer>& c_ids_v = tC.value();
            Integer dimc = compute_size(c_ids_v); if (dimc<=0) continue;
            double* buf_c_sort = new double[dimc];
            memset(buf_c_sort, 0, dimc*sizeof(double));

            sum_itr.reset();
            bool ONE_TIME = sum_itr.empty();
            while (sum_itr.next(sum_vec) || ONE_TIME) {

              ONE_TIME = false;
              for (int i=0; i<sum_ids.size(); i++) {
                tA.setValueByName(sum_ids[i],sum_vec[i]);
                tB.setValueByName(sum_ids[i],sum_vec[i]);
              }
              vector<Integer>& a_ids_v = tA.value();
              vector<Integer>& b_ids_v = tB.value();
              if (!is_spatial_nonzero(a_ids_v, tA.irrep())) continue;
              if (!is_spin_nonzero(a_ids_v)) continue;

              tA.gen_restricted();
              tB.gen_restricted();

              Integer dim_common = compute_size(sum_vec);
              Integer dima = compute_size(a_ids_v); if (dima<=0) continue;
              Integer dimb = compute_size(b_ids_v); if (dimb<=0) continue;
              Integer dima_sort = dima / dim_common;
              Integer dimb_sort = dimb / dim_common;

              double* buf_a = new double[dima];
              double* buf_a_sort = new double[dima];
              tA.sortByValueThenExtSymGroup();
              if (tA.dim()==2) tA.get_ma = true;
              tA.get(*d_a,buf_a,dima,*k_a_offset);
              tce_sort(buf_a, buf_a_sort, tA._value(), tA.sort_ids(), (double)tA.sign());
              delete [] buf_a;

              double* buf_b = new double[dimb];
              double* buf_b_sort = new double[dimb];
              tB.sortByValueThenExtSymGroup();
              if (!tB.isIntermediate()) tB.get_i = true;
              tB.get(*d_b,buf_b,dimb,*k_b_offset);
              tce_sort(buf_b, buf_b_sort, tB._value(), tB.sort_ids(), (double)tB.sign());
              delete [] buf_b;

              double beta = computeBeta(sum_ids,sum_vec);

              cdgemm('T','N',dima_sort, dimb_sort, dim_common, beta, buf_a_sort,
                  dim_common, buf_b_sort, dim_common, 1.0, buf_c_sort, dima_sort);

              delete [] buf_a_sort;
              delete [] buf_b_sort;
            } // sum_itr

            tC.sortByValueThenExtSymGroup();
            vector<Integer> tid = tC._value();

            cp_itr.reset();
            vector<Integer> perm;
            while (cp_itr.next(perm)) {
              cp_itr.fix_ids_for_copy(perm);
              tC.orderIds(perm);
              if (compareVec<Integer>(tid, tC._value())) {
                double sign = coef * cp_itr.sign();
                double* buf_c = new double[dimc];
                tce_sort(buf_c_sort, buf_c, tC.getMemPosVal(), tC.perm(), sign);

                tce_add_hash_block_(d_c, buf_c, dimc, *k_c_offset, tC._value(), tC._name());

                delete [] buf_c;
              }
            } // cp_itr
            delete [] buf_c_sort;
          } // if spatial symmetry check

          next = NGA_Read_inc(taskHandle, &sub, 1);  // get my next task

        } // if next == count

        ++count; // no matter my or not, increase by one

      } // out_itr

      GA_Sync(); // sync, wait for all procs to finish
      GA_Destroy(taskHandle); // free

    } // t_mult3

    void t_mult4(Integer* d_a, Integer* k_a_offset, Integer* d_b, Integer* k_b_offset,
        Integer* d_c, Integer* k_c_offset, Multiplication& m) {

      t_mult3(d_a, k_a_offset, d_b, k_b_offset, d_c, k_c_offset,
          m.tC(), m.tA(), m.tB(), m.coef(), m.sum_ids(),
          m.sum_itr(), m.cp_itr(), m.out_itr());
    }

  } /*extern "C"*/

}; // namespace ctce
