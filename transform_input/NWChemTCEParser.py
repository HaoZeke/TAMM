# Generated from /home/panyala/EclipseWS/workspacePTP/ctce/ctce_parser/transform_input/NWChemTCE.g4 by ANTLR 4.5.3
# encoding: utf-8
from __future__ import print_function
from antlr4 import *
from io import StringIO

def serializedATN():
    with StringIO() as buf:
        buf.write(u"\3\u0430\ud6d1\u8206\uad2d\u4417\uaef1\u8d80\uaadd\3")
        buf.write(u"\24m\4\2\t\2\4\3\t\3\4\4\t\4\4\5\t\5\4\6\t\6\4\7\t\7")
        buf.write(u"\4\b\t\b\4\t\t\t\4\n\t\n\4\13\t\13\4\f\t\f\4\r\t\r\4")
        buf.write(u"\16\t\16\3\2\3\2\3\2\3\2\3\2\3\2\3\2\5\2$\n\2\3\3\3\3")
        buf.write(u"\3\4\3\4\3\5\3\5\3\6\3\6\5\6.\n\6\3\7\6\7\61\n\7\r\7")
        buf.write(u"\16\7\62\3\b\3\b\3\b\3\b\3\t\3\t\3\t\3\t\3\t\3\n\3\n")
        buf.write(u"\3\n\3\n\5\nB\n\n\3\n\5\nE\n\n\3\n\6\nH\n\n\r\n\16\n")
        buf.write(u"I\6\nL\n\n\r\n\16\nM\3\n\3\n\3\13\3\13\3\13\7\13U\n\13")
        buf.write(u"\f\13\16\13X\13\13\3\13\3\13\3\f\7\f]\n\f\f\f\16\f`\13")
        buf.write(u"\f\3\r\3\r\3\16\3\16\3\16\3\16\3\16\3\16\3\16\5\16k\n")
        buf.write(u"\16\3\16\2\2\17\2\4\6\b\n\f\16\20\22\24\26\30\32\2\4")
        buf.write(u"\3\2\20\22\3\2\5\6m\2#\3\2\2\2\4%\3\2\2\2\6\'\3\2\2\2")
        buf.write(u"\b)\3\2\2\2\n-\3\2\2\2\f\60\3\2\2\2\16\64\3\2\2\2\20")
        buf.write(u"8\3\2\2\2\22K\3\2\2\2\24Q\3\2\2\2\26^\3\2\2\2\30a\3\2")
        buf.write(u"\2\2\32j\3\2\2\2\34$\7\b\2\2\35\36\7\5\2\2\36$\7\b\2")
        buf.write(u"\2\37 \7\6\2\2 $\7\b\2\2!\"\7\7\2\2\"$\7\b\2\2#\34\3")
        buf.write(u"\2\2\2#\35\3\2\2\2#\37\3\2\2\2#!\3\2\2\2$\3\3\2\2\2%")
        buf.write(u"&\t\2\2\2&\5\3\2\2\2\'(\t\3\2\2(\7\3\2\2\2)*\5\n\6\2")
        buf.write(u"*\t\3\2\2\2+.\7\2\2\3,.\5\f\7\2-+\3\2\2\2-,\3\2\2\2.")
        buf.write(u"\13\3\2\2\2/\61\5\16\b\2\60/\3\2\2\2\61\62\3\2\2\2\62")
        buf.write(u"\60\3\2\2\2\62\63\3\2\2\2\63\r\3\2\2\2\64\65\5\32\16")
        buf.write(u"\2\65\66\5\2\2\2\66\67\5\22\n\2\67\17\3\2\2\289\7\3\2")
        buf.write(u"\29:\7\t\2\2:;\5\4\3\2;<\7\n\2\2<\21\3\2\2\2=A\7\7\2")
        buf.write(u"\2>B\5\20\t\2?B\5\24\13\2@B\5\32\16\2A>\3\2\2\2A?\3\2")
        buf.write(u"\2\2A@\3\2\2\2BL\3\2\2\2CE\5\6\4\2DC\3\2\2\2DE\3\2\2")
        buf.write(u"\2EF\3\2\2\2FH\5\4\3\2GD\3\2\2\2HI\3\2\2\2IG\3\2\2\2")
        buf.write(u"IJ\3\2\2\2JL\3\2\2\2K=\3\2\2\2KG\3\2\2\2LM\3\2\2\2MK")
        buf.write(u"\3\2\2\2MN\3\2\2\2NO\3\2\2\2OP\7\16\2\2P\23\3\2\2\2Q")
        buf.write(u"R\7\4\2\2RV\7\t\2\2SU\5\30\r\2TS\3\2\2\2UX\3\2\2\2VT")
        buf.write(u"\3\2\2\2VW\3\2\2\2WY\3\2\2\2XV\3\2\2\2YZ\7\n\2\2Z\25")
        buf.write(u"\3\2\2\2[]\5\30\r\2\\[\3\2\2\2]`\3\2\2\2^\\\3\2\2\2^")
        buf.write(u"_\3\2\2\2_\27\3\2\2\2`^\3\2\2\2ab\7\17\2\2b\31\3\2\2")
        buf.write(u"\2ck\7\17\2\2de\7\17\2\2ef\7\t\2\2fg\5\26\f\2gh\7\n\2")
        buf.write(u"\2hi\5\30\r\2ik\3\2\2\2jc\3\2\2\2jd\3\2\2\2k\33\3\2\2")
        buf.write(u"\2\r#-\62ADIKMV^j")
        return buf.getvalue()


class NWChemTCEParser ( Parser ):

    grammarFileName = "NWChemTCE.g4"

    atn = ATNDeserializer().deserialize(serializedATN())

    decisionsToDFA = [ DFA(ds, i) for i, ds in enumerate(atn.decisionToState) ]

    sharedContextCache = PredictionContextCache()

    literalNames = [ u"<INVALID>", u"'P'", u"'Sum'", u"'+'", u"'-'", u"'*'", 
                     u"'='", u"'('", u"')'", u"'['", u"']'", u"'=>'", u"';'" ]

    symbolicNames = [ u"<INVALID>", u"<INVALID>", u"SUM", u"PLUS", u"MINUS", 
                      u"TIMES", u"EQUALS", u"LPAREN", u"RPAREN", u"LBRACKET", 
                      u"RBRACKET", u"SYMOP", u"SEMI", u"ID", u"ICONST", 
                      u"FCONST", u"FRAC", u"COMMENT", u"WS" ]

    RULE_assignment_operator = 0
    RULE_numerical_constant = 1
    RULE_plusORminus = 2
    RULE_translation_unit = 3
    RULE_compound_element_list_opt = 4
    RULE_compound_element_list = 5
    RULE_statement = 6
    RULE_perm = 7
    RULE_ptype = 8
    RULE_sumExp = 9
    RULE_id_list = 10
    RULE_identifier = 11
    RULE_array_reference = 12

    ruleNames =  [ u"assignment_operator", u"numerical_constant", u"plusORminus", 
                   u"translation_unit", u"compound_element_list_opt", u"compound_element_list", 
                   u"statement", u"perm", u"ptype", u"sumExp", u"id_list", 
                   u"identifier", u"array_reference" ]

    EOF = Token.EOF
    T__0=1
    SUM=2
    PLUS=3
    MINUS=4
    TIMES=5
    EQUALS=6
    LPAREN=7
    RPAREN=8
    LBRACKET=9
    RBRACKET=10
    SYMOP=11
    SEMI=12
    ID=13
    ICONST=14
    FCONST=15
    FRAC=16
    COMMENT=17
    WS=18

    def __init__(self, input):
        super(NWChemTCEParser, self).__init__(input)
        self.checkVersion("4.5.3")
        self._interp = ParserATNSimulator(self, self.atn, self.decisionsToDFA, self.sharedContextCache)
        self._predicates = None



    class Assignment_operatorContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(NWChemTCEParser.Assignment_operatorContext, self).__init__(parent, invokingState)
            self.parser = parser

        def EQUALS(self):
            return self.getToken(NWChemTCEParser.EQUALS, 0)

        def PLUS(self):
            return self.getToken(NWChemTCEParser.PLUS, 0)

        def MINUS(self):
            return self.getToken(NWChemTCEParser.MINUS, 0)

        def TIMES(self):
            return self.getToken(NWChemTCEParser.TIMES, 0)

        def getRuleIndex(self):
            return NWChemTCEParser.RULE_assignment_operator

        def enterRule(self, listener):
            if hasattr(listener, "enterAssignment_operator"):
                listener.enterAssignment_operator(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitAssignment_operator"):
                listener.exitAssignment_operator(self)

        def accept(self, visitor):
            if hasattr(visitor, "visitAssignment_operator"):
                return visitor.visitAssignment_operator(self)
            else:
                return visitor.visitChildren(self)




    def assignment_operator(self):

        localctx = NWChemTCEParser.Assignment_operatorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 0, self.RULE_assignment_operator)
        try:
            self.state = 33
            token = self._input.LA(1)
            if token in [NWChemTCEParser.EQUALS]:
                self.enterOuterAlt(localctx, 1)
                self.state = 26
                self.match(NWChemTCEParser.EQUALS)

            elif token in [NWChemTCEParser.PLUS]:
                self.enterOuterAlt(localctx, 2)
                self.state = 27
                self.match(NWChemTCEParser.PLUS)
                self.state = 28
                self.match(NWChemTCEParser.EQUALS)

            elif token in [NWChemTCEParser.MINUS]:
                self.enterOuterAlt(localctx, 3)
                self.state = 29
                self.match(NWChemTCEParser.MINUS)
                self.state = 30
                self.match(NWChemTCEParser.EQUALS)

            elif token in [NWChemTCEParser.TIMES]:
                self.enterOuterAlt(localctx, 4)
                self.state = 31
                self.match(NWChemTCEParser.TIMES)
                self.state = 32
                self.match(NWChemTCEParser.EQUALS)

            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Numerical_constantContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(NWChemTCEParser.Numerical_constantContext, self).__init__(parent, invokingState)
            self.parser = parser

        def ICONST(self):
            return self.getToken(NWChemTCEParser.ICONST, 0)

        def FCONST(self):
            return self.getToken(NWChemTCEParser.FCONST, 0)

        def FRAC(self):
            return self.getToken(NWChemTCEParser.FRAC, 0)

        def getRuleIndex(self):
            return NWChemTCEParser.RULE_numerical_constant

        def enterRule(self, listener):
            if hasattr(listener, "enterNumerical_constant"):
                listener.enterNumerical_constant(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitNumerical_constant"):
                listener.exitNumerical_constant(self)

        def accept(self, visitor):
            if hasattr(visitor, "visitNumerical_constant"):
                return visitor.visitNumerical_constant(self)
            else:
                return visitor.visitChildren(self)




    def numerical_constant(self):

        localctx = NWChemTCEParser.Numerical_constantContext(self, self._ctx, self.state)
        self.enterRule(localctx, 2, self.RULE_numerical_constant)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 35
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << NWChemTCEParser.ICONST) | (1 << NWChemTCEParser.FCONST) | (1 << NWChemTCEParser.FRAC))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class PlusORminusContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(NWChemTCEParser.PlusORminusContext, self).__init__(parent, invokingState)
            self.parser = parser

        def PLUS(self):
            return self.getToken(NWChemTCEParser.PLUS, 0)

        def MINUS(self):
            return self.getToken(NWChemTCEParser.MINUS, 0)

        def getRuleIndex(self):
            return NWChemTCEParser.RULE_plusORminus

        def enterRule(self, listener):
            if hasattr(listener, "enterPlusORminus"):
                listener.enterPlusORminus(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitPlusORminus"):
                listener.exitPlusORminus(self)

        def accept(self, visitor):
            if hasattr(visitor, "visitPlusORminus"):
                return visitor.visitPlusORminus(self)
            else:
                return visitor.visitChildren(self)




    def plusORminus(self):

        localctx = NWChemTCEParser.PlusORminusContext(self, self._ctx, self.state)
        self.enterRule(localctx, 4, self.RULE_plusORminus)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 37
            _la = self._input.LA(1)
            if not(_la==NWChemTCEParser.PLUS or _la==NWChemTCEParser.MINUS):
                self._errHandler.recoverInline(self)
            else:
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Translation_unitContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(NWChemTCEParser.Translation_unitContext, self).__init__(parent, invokingState)
            self.parser = parser

        def compound_element_list_opt(self):
            return self.getTypedRuleContext(NWChemTCEParser.Compound_element_list_optContext,0)


        def getRuleIndex(self):
            return NWChemTCEParser.RULE_translation_unit

        def enterRule(self, listener):
            if hasattr(listener, "enterTranslation_unit"):
                listener.enterTranslation_unit(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitTranslation_unit"):
                listener.exitTranslation_unit(self)

        def accept(self, visitor):
            if hasattr(visitor, "visitTranslation_unit"):
                return visitor.visitTranslation_unit(self)
            else:
                return visitor.visitChildren(self)




    def translation_unit(self):

        localctx = NWChemTCEParser.Translation_unitContext(self, self._ctx, self.state)
        self.enterRule(localctx, 6, self.RULE_translation_unit)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 39
            self.compound_element_list_opt()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Compound_element_list_optContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(NWChemTCEParser.Compound_element_list_optContext, self).__init__(parent, invokingState)
            self.parser = parser

        def EOF(self):
            return self.getToken(NWChemTCEParser.EOF, 0)

        def compound_element_list(self):
            return self.getTypedRuleContext(NWChemTCEParser.Compound_element_listContext,0)


        def getRuleIndex(self):
            return NWChemTCEParser.RULE_compound_element_list_opt

        def enterRule(self, listener):
            if hasattr(listener, "enterCompound_element_list_opt"):
                listener.enterCompound_element_list_opt(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitCompound_element_list_opt"):
                listener.exitCompound_element_list_opt(self)

        def accept(self, visitor):
            if hasattr(visitor, "visitCompound_element_list_opt"):
                return visitor.visitCompound_element_list_opt(self)
            else:
                return visitor.visitChildren(self)




    def compound_element_list_opt(self):

        localctx = NWChemTCEParser.Compound_element_list_optContext(self, self._ctx, self.state)
        self.enterRule(localctx, 8, self.RULE_compound_element_list_opt)
        try:
            self.state = 43
            token = self._input.LA(1)
            if token in [NWChemTCEParser.EOF]:
                self.enterOuterAlt(localctx, 1)
                self.state = 41
                self.match(NWChemTCEParser.EOF)

            elif token in [NWChemTCEParser.ID]:
                self.enterOuterAlt(localctx, 2)
                self.state = 42
                self.compound_element_list()

            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Compound_element_listContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(NWChemTCEParser.Compound_element_listContext, self).__init__(parent, invokingState)
            self.parser = parser

        def statement(self, i=None):
            if i is None:
                return self.getTypedRuleContexts(NWChemTCEParser.StatementContext)
            else:
                return self.getTypedRuleContext(NWChemTCEParser.StatementContext,i)


        def getRuleIndex(self):
            return NWChemTCEParser.RULE_compound_element_list

        def enterRule(self, listener):
            if hasattr(listener, "enterCompound_element_list"):
                listener.enterCompound_element_list(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitCompound_element_list"):
                listener.exitCompound_element_list(self)

        def accept(self, visitor):
            if hasattr(visitor, "visitCompound_element_list"):
                return visitor.visitCompound_element_list(self)
            else:
                return visitor.visitChildren(self)




    def compound_element_list(self):

        localctx = NWChemTCEParser.Compound_element_listContext(self, self._ctx, self.state)
        self.enterRule(localctx, 10, self.RULE_compound_element_list)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 46 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 45
                self.statement()
                self.state = 48 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la==NWChemTCEParser.ID):
                    break

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class StatementContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(NWChemTCEParser.StatementContext, self).__init__(parent, invokingState)
            self.parser = parser

        def array_reference(self):
            return self.getTypedRuleContext(NWChemTCEParser.Array_referenceContext,0)


        def assignment_operator(self):
            return self.getTypedRuleContext(NWChemTCEParser.Assignment_operatorContext,0)


        def ptype(self):
            return self.getTypedRuleContext(NWChemTCEParser.PtypeContext,0)


        def getRuleIndex(self):
            return NWChemTCEParser.RULE_statement

        def enterRule(self, listener):
            if hasattr(listener, "enterStatement"):
                listener.enterStatement(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitStatement"):
                listener.exitStatement(self)

        def accept(self, visitor):
            if hasattr(visitor, "visitStatement"):
                return visitor.visitStatement(self)
            else:
                return visitor.visitChildren(self)




    def statement(self):

        localctx = NWChemTCEParser.StatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 12, self.RULE_statement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 50
            self.array_reference()
            self.state = 51
            self.assignment_operator()
            self.state = 52
            self.ptype()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class PermContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(NWChemTCEParser.PermContext, self).__init__(parent, invokingState)
            self.parser = parser

        def LPAREN(self):
            return self.getToken(NWChemTCEParser.LPAREN, 0)

        def numerical_constant(self):
            return self.getTypedRuleContext(NWChemTCEParser.Numerical_constantContext,0)


        def RPAREN(self):
            return self.getToken(NWChemTCEParser.RPAREN, 0)

        def getRuleIndex(self):
            return NWChemTCEParser.RULE_perm

        def enterRule(self, listener):
            if hasattr(listener, "enterPerm"):
                listener.enterPerm(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitPerm"):
                listener.exitPerm(self)

        def accept(self, visitor):
            if hasattr(visitor, "visitPerm"):
                return visitor.visitPerm(self)
            else:
                return visitor.visitChildren(self)




    def perm(self):

        localctx = NWChemTCEParser.PermContext(self, self._ctx, self.state)
        self.enterRule(localctx, 14, self.RULE_perm)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 54
            self.match(NWChemTCEParser.T__0)
            self.state = 55
            self.match(NWChemTCEParser.LPAREN)
            self.state = 56
            self.numerical_constant()
            self.state = 57
            self.match(NWChemTCEParser.RPAREN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class PtypeContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(NWChemTCEParser.PtypeContext, self).__init__(parent, invokingState)
            self.parser = parser

        def SEMI(self):
            return self.getToken(NWChemTCEParser.SEMI, 0)

        def TIMES(self, i=None):
            if i is None:
                return self.getTokens(NWChemTCEParser.TIMES)
            else:
                return self.getToken(NWChemTCEParser.TIMES, i)

        def perm(self, i=None):
            if i is None:
                return self.getTypedRuleContexts(NWChemTCEParser.PermContext)
            else:
                return self.getTypedRuleContext(NWChemTCEParser.PermContext,i)


        def sumExp(self, i=None):
            if i is None:
                return self.getTypedRuleContexts(NWChemTCEParser.SumExpContext)
            else:
                return self.getTypedRuleContext(NWChemTCEParser.SumExpContext,i)


        def array_reference(self, i=None):
            if i is None:
                return self.getTypedRuleContexts(NWChemTCEParser.Array_referenceContext)
            else:
                return self.getTypedRuleContext(NWChemTCEParser.Array_referenceContext,i)


        def numerical_constant(self, i=None):
            if i is None:
                return self.getTypedRuleContexts(NWChemTCEParser.Numerical_constantContext)
            else:
                return self.getTypedRuleContext(NWChemTCEParser.Numerical_constantContext,i)


        def plusORminus(self, i=None):
            if i is None:
                return self.getTypedRuleContexts(NWChemTCEParser.PlusORminusContext)
            else:
                return self.getTypedRuleContext(NWChemTCEParser.PlusORminusContext,i)


        def getRuleIndex(self):
            return NWChemTCEParser.RULE_ptype

        def enterRule(self, listener):
            if hasattr(listener, "enterPtype"):
                listener.enterPtype(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitPtype"):
                listener.exitPtype(self)

        def accept(self, visitor):
            if hasattr(visitor, "visitPtype"):
                return visitor.visitPtype(self)
            else:
                return visitor.visitChildren(self)




    def ptype(self):

        localctx = NWChemTCEParser.PtypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 16, self.RULE_ptype)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 73 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 73
                token = self._input.LA(1)
                if token in [NWChemTCEParser.TIMES]:
                    self.state = 59
                    self.match(NWChemTCEParser.TIMES)
                    self.state = 63
                    token = self._input.LA(1)
                    if token in [NWChemTCEParser.T__0]:
                        self.state = 60
                        self.perm()

                    elif token in [NWChemTCEParser.SUM]:
                        self.state = 61
                        self.sumExp()

                    elif token in [NWChemTCEParser.ID]:
                        self.state = 62
                        self.array_reference()

                    else:
                        raise NoViableAltException(self)


                elif token in [NWChemTCEParser.PLUS, NWChemTCEParser.MINUS, NWChemTCEParser.ICONST, NWChemTCEParser.FCONST, NWChemTCEParser.FRAC]:
                    self.state = 69 
                    self._errHandler.sync(self)
                    _alt = 1
                    while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                        if _alt == 1:
                            self.state = 66
                            _la = self._input.LA(1)
                            if _la==NWChemTCEParser.PLUS or _la==NWChemTCEParser.MINUS:
                                self.state = 65
                                self.plusORminus()


                            self.state = 68
                            self.numerical_constant()

                        else:
                            raise NoViableAltException(self)
                        self.state = 71 
                        self._errHandler.sync(self)
                        _alt = self._interp.adaptivePredict(self._input,5,self._ctx)


                else:
                    raise NoViableAltException(self)

                self.state = 75 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not ((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << NWChemTCEParser.PLUS) | (1 << NWChemTCEParser.MINUS) | (1 << NWChemTCEParser.TIMES) | (1 << NWChemTCEParser.ICONST) | (1 << NWChemTCEParser.FCONST) | (1 << NWChemTCEParser.FRAC))) != 0)):
                    break

            self.state = 77
            self.match(NWChemTCEParser.SEMI)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class SumExpContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(NWChemTCEParser.SumExpContext, self).__init__(parent, invokingState)
            self.parser = parser

        def SUM(self):
            return self.getToken(NWChemTCEParser.SUM, 0)

        def LPAREN(self):
            return self.getToken(NWChemTCEParser.LPAREN, 0)

        def RPAREN(self):
            return self.getToken(NWChemTCEParser.RPAREN, 0)

        def identifier(self, i=None):
            if i is None:
                return self.getTypedRuleContexts(NWChemTCEParser.IdentifierContext)
            else:
                return self.getTypedRuleContext(NWChemTCEParser.IdentifierContext,i)


        def getRuleIndex(self):
            return NWChemTCEParser.RULE_sumExp

        def enterRule(self, listener):
            if hasattr(listener, "enterSumExp"):
                listener.enterSumExp(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitSumExp"):
                listener.exitSumExp(self)

        def accept(self, visitor):
            if hasattr(visitor, "visitSumExp"):
                return visitor.visitSumExp(self)
            else:
                return visitor.visitChildren(self)




    def sumExp(self):

        localctx = NWChemTCEParser.SumExpContext(self, self._ctx, self.state)
        self.enterRule(localctx, 18, self.RULE_sumExp)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 79
            self.match(NWChemTCEParser.SUM)
            self.state = 80
            self.match(NWChemTCEParser.LPAREN)
            self.state = 84
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==NWChemTCEParser.ID:
                self.state = 81
                self.identifier()
                self.state = 86
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 87
            self.match(NWChemTCEParser.RPAREN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Id_listContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(NWChemTCEParser.Id_listContext, self).__init__(parent, invokingState)
            self.parser = parser

        def identifier(self, i=None):
            if i is None:
                return self.getTypedRuleContexts(NWChemTCEParser.IdentifierContext)
            else:
                return self.getTypedRuleContext(NWChemTCEParser.IdentifierContext,i)


        def getRuleIndex(self):
            return NWChemTCEParser.RULE_id_list

        def enterRule(self, listener):
            if hasattr(listener, "enterId_list"):
                listener.enterId_list(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitId_list"):
                listener.exitId_list(self)

        def accept(self, visitor):
            if hasattr(visitor, "visitId_list"):
                return visitor.visitId_list(self)
            else:
                return visitor.visitChildren(self)




    def id_list(self):

        localctx = NWChemTCEParser.Id_listContext(self, self._ctx, self.state)
        self.enterRule(localctx, 20, self.RULE_id_list)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 92
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==NWChemTCEParser.ID:
                self.state = 89
                self.identifier()
                self.state = 94
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class IdentifierContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(NWChemTCEParser.IdentifierContext, self).__init__(parent, invokingState)
            self.parser = parser

        def ID(self):
            return self.getToken(NWChemTCEParser.ID, 0)

        def getRuleIndex(self):
            return NWChemTCEParser.RULE_identifier

        def enterRule(self, listener):
            if hasattr(listener, "enterIdentifier"):
                listener.enterIdentifier(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitIdentifier"):
                listener.exitIdentifier(self)

        def accept(self, visitor):
            if hasattr(visitor, "visitIdentifier"):
                return visitor.visitIdentifier(self)
            else:
                return visitor.visitChildren(self)




    def identifier(self):

        localctx = NWChemTCEParser.IdentifierContext(self, self._ctx, self.state)
        self.enterRule(localctx, 22, self.RULE_identifier)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 95
            self.match(NWChemTCEParser.ID)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Array_referenceContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(NWChemTCEParser.Array_referenceContext, self).__init__(parent, invokingState)
            self.parser = parser

        def ID(self):
            return self.getToken(NWChemTCEParser.ID, 0)

        def LPAREN(self):
            return self.getToken(NWChemTCEParser.LPAREN, 0)

        def id_list(self):
            return self.getTypedRuleContext(NWChemTCEParser.Id_listContext,0)


        def RPAREN(self):
            return self.getToken(NWChemTCEParser.RPAREN, 0)

        def identifier(self):
            return self.getTypedRuleContext(NWChemTCEParser.IdentifierContext,0)


        def getRuleIndex(self):
            return NWChemTCEParser.RULE_array_reference

        def enterRule(self, listener):
            if hasattr(listener, "enterArray_reference"):
                listener.enterArray_reference(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitArray_reference"):
                listener.exitArray_reference(self)

        def accept(self, visitor):
            if hasattr(visitor, "visitArray_reference"):
                return visitor.visitArray_reference(self)
            else:
                return visitor.visitChildren(self)




    def array_reference(self):

        localctx = NWChemTCEParser.Array_referenceContext(self, self._ctx, self.state)
        self.enterRule(localctx, 24, self.RULE_array_reference)
        try:
            self.state = 104
            self._errHandler.sync(self);
            la_ = self._interp.adaptivePredict(self._input,10,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 97
                self.match(NWChemTCEParser.ID)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 98
                self.match(NWChemTCEParser.ID)
                self.state = 99
                self.match(NWChemTCEParser.LPAREN)
                self.state = 100
                self.id_list()
                self.state = 101
                self.match(NWChemTCEParser.RPAREN)
                self.state = 102
                self.identifier()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx





